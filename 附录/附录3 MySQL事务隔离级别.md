# 附录3 MySQL事务隔离级别

## 读未提交(READ UNCOMMITTED)

- 特点: 1个事务可以读取到其他事务未提交的数据(脏读)
- 问题:
	- 脏读(Dirty Read): 可以读到其他事务尚未提交的数据
	- 不可重复读(Non-repeatable Read): 同一条数据在同一事务内多次读取,结果可能不一样
	- 幻读(Phantom Read): 同一事务内2次查询,记录条数可能不同
- 适用场景: 很少用,数据一致性要求极低

## 读已提交(READ COMMITED)

- 特点: 只能读取到其他事务已经提交的数据,不会出现脏读
- 问题:
	- 不可重复读: 同一事务内,2次读取同一条数据,数据内容可能发生变化(因为别的事务已经提交了新的数据)
	- 幻读: 可能出现
- 适用场景: 对一致性有一定要求,但允许一定程度的并发(Oracle默认隔离级别)

## 可重复读(REPEATABLE READ)

- 特点: 同一事务内多次读取同一条记录,结果是一样的(除非事务自身内部做了修改),不会出现脏读和不可重复读
- 问题:
	- 幻读: 可能出现(但是在MySQL的InnoDB存储引擎下,采用了**间隙锁(Next-Key Lock)**机制,可防止幻读)
- 使用场景: 适用于大多业务系统(MySQL的默认隔离级别)

## 串行化(SERIALIZABLE)

- 特点: 事务完全串行执行,彼此之间完全隔离,**相当于加表锁**
- 问题:
	- 性能最差,几乎没有并发性
	- 不会出现脏读/不可重复读/幻读
- 适用场景: 强一致性要求的场景,非常少用

## 各个级别出现的问题对比表

|隔离级别|脏读|不可重复读|幻读|
|:-:|:-:|:-:|:-:|
|READ UNCOMMITTED|可能|可能|可能|
|READ COMMITTED|不可能|可能|可能|
|REPEATABLE READ|不可能|不可能|可能(实际上InnoDB已经通过Next-Key Lock机制避免了这个问题)|
|SERIALIZABLE|不可能|不可能|不可能|